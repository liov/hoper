在使用Java进行并发编程时需要特别的关注锁和内存原子性等一系列线程问题，而Actor模型内部的状态由它自己维护即它内部数据只能由它自己修改(通过消息传递来进行状态修改)，所以使用Actors模型进行并发编程可以很好地避免这些问题，Actor由状态(state)、行为(Behavior)和邮箱(mailBox)三部分组成

状态(state)：Actor中的状态指的是Actor对象的变量信息，状态由Actor自己管理，避免了并发环境下的锁和内存原子性等问题
行为(Behavior)：行为指定的是Actor中计算逻辑，通过Actor接收到消息来改变Actor的状态
邮箱(mailBox)：邮箱是Actor和Actor之间的通信桥梁，邮箱内部通过FIFO消息队列来存储发送方Actor消息，接受方Actor从邮箱队列中获取消息
Actor的基础就是消息传递
2.使用Actor模型的好处：
事件模型驱动--Actor之间的通信是异步的，即使Actor在发送消息后也无需阻塞或者等待就能够处理其他事情
强隔离性--Actor中的方法不能由外部直接调用，所有的一切都通过消息传递进行的，从而避免了Actor之间的数据共享，想要
观察到另一个Actor的状态变化只能通过消息传递进行询问
位置透明--无论Actor地址是在本地还是在远程机上对于代码来说都是一样的
轻量性--Actor是非常轻量的计算单机，单个Actor仅占400多字节，只需少量内存就能达到高并发 
 

Actor模型概念
     Actor模型为并行而生，简单说是未解决高并发的一种编程思路。在Actor模型中，主角是Actor，类似一种worker，Actor彼此之间直接发送消息，不需要经过什么中介，消息是异步发送和处理的。在Actor模式中，“一切皆是Actor”，所有逻辑或者模块均别看做Actor，通过不同Actor之间的消息传递实现模块之间的通信和交互。Actor模型描述了一组为了避免并发编程的常见问题的公理:

1.所有Actor状态是Actor本地的，外部无法访问。 
2.Actor必须只有通过消息传递进行通信。 
3.一个Actor可以响应消息:推出新Actor,改变其内部状态,或将消息发送到一个或多个其他参与者。 
4.Actor可能会堵塞自己,但Actor不应该堵塞它运行的线程。

 

    

Actor优点、缺点分析
     传统的并发编程方式大都使用“锁”的机制，相信大多数都是”悲观锁“，这里几乎可以断定会出现两个明显的问题：

    1.随着项目体量增大，业务愈加复杂，不可避免大量使用“锁”，然而大家都知道“锁”的机制其实很耗性能的，所以大量使用锁的机制肯定会造成效率不高

    2.即使大量依赖“锁”解决了系统中资源竞争的情况，但是由于没有一个规范的编程模式，最后系统的稳定性肯定会出问题，最根本的原因是没把系统的任务调度抽象出来，由于任务调度和业务逻辑的耦合在一起，很难做一个很高层的抽象，保证任务调度有序。

    3.难以维护等等弊端

    上面是传统通过“锁”的机制实现并发编程的缺点，然而Actor为什么一定层度上可以解决这些问题呢？个人认为其最根本的原因是Actor模式下提供了一种可靠的任务调度系统，也就是在原生的线程或者协程级别上做了更高层次的封装。这会给编程模式带来巨大的好处：

    1.由于抽象了任务调度系统，那么就可以使系统的线程调度可控，易于统一处理，稳定性和可维护性好

    2.作为开发者我们只需要关心每个Actor的逻辑就可以了，避免“锁”的“滥用”

    3.Actor也提供了很多基本准则，避免了很多并发编程中的问题 

    ……

那么Actor没有缺点吗？那也不是，比如当所有逻辑都跑在Actor中时，很难掌控Actor的粒度，稍有不慎就可能造成系统中Actor个数爆炸的情况，Actor当出现必须共享数据或者状态时就很难避免使用“锁”，但似乎由于上面的“Actor可能会堵塞自己,但Actor不应该堵塞它运行的线程”准则冲突，哈哈，这个时候也许可以选择使用redis做数据共享